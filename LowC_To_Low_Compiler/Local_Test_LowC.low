subroutine Set_Interrupt_Function
{
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ???; 0
		# L = ???; 0
	HL = SP + 2;		# Fetches Function_Pointer off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	B = H;		# Moves @statement_value@ into upper register
	C = L;		# Moves into lower register
	HL = SP + 4;		# Fetches Address off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	[HL] = C; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 1
		# C = Function_Pointer; 1
		# D = ???; 0
		# E = ???; 0
		# H = Address; 0
		# L = Address; 0
	HL = SP + 4;		# Fetches Address off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL++;		# Increments Address
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 1
		# C = Function_Pointer; 1
		# D = ???; 0
		# E = ???; 0
		# H = Address; 1
		# L = Address; 1
	D = H;		# Makes 'H' a copy of Address
	E = L;		# Makes 'L' a copy of L
	[HL] = B; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 1
		# C = Function_Pointer; 1
		# D = Address; 1
		# E = Address; 1
		# H = Address; 0
		# L = Address; 0
	return;
}

subroutine Wait_For_VBlank
{
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = Address; 0
		# L = Address; 0
	SP += 255;		# byte Scanline;
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = Address; 0
		# L = Address; 0

	label __do_while_statement__0;		# do/while loop label
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = Address; 0
		# L = Address; 0
	HL = $FF44;
	A = [HL];		# Dereferences address
	A < $90;		# S_LESS_THAN8
	jump  not_carry __do_while_statement__0_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = Scanline; 1
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:
	jump __do_while_statement__0;		# do/while loop jump
	label __do_while_statement__0_memory_cleanup;
	# Current tracer registers:
		# A = Scanline; 1
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:


	# Current tracer registers:
		# A = Scanline; 1
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = ; 0
		# L = ; 0
	SP += 1;		# Remove local variables from stack
	return;
}

subroutine Conditional_Checker
{
	# Current tracer registers:
		# A = Scanline; 0
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = ; 0
		# L = ; 0
	HL = SP + 6;		# Fetches Write_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Function_Pointer; 0
		# C = Function_Pointer; 0
		# D = Address; 0
		# E = Address; 0
		# H = Write_Head; 1
		# L = Write_Head; 1
	B = H;		# Moves Write_Head into upper register
	C = L;		# Moves into lower register
	HL = SP + 4;		# Fetches Read_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Address; 0
		# E = Address; 0
		# H = Read_Head; 1
		# L = Read_Head; 1
	D = H;		# Moves Read_Head into upper register
	E = L;		# Moves into lower register
	HL = SP + 2;		# Fetches Counter off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1

	A = H;		# Copies high byte of Counter into register
	push BC;		# Makes room by pushing Write_Head to stack.
	A = L;		# copies lower byte into A register
	A |= B;		# S_OR8
	A |= A;		# This just gets the CPU flags
	jump zero __if_statement__1;		# If statement jump
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = ???; 0
		# C = ???; 0
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1

	label __do_while_statement__2;		# do/while loop label
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = ???; 0
		# C = ???; 0
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1
	B = H;		# Moves Counter into upper register
	C = L;		# Moves into lower register
	H = D;		# Creates copy of Read_Head
	L = E;		# Creates copy of Read_Head
	A = [HL];		# Dereferences address
	push BC;		# Makes room by pushing Counter to stack.
	HL = SP + 2;		# Fetches Write_Head off the stack
	B = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = B;		# Move lower byte from temp register
	[HL] = A; 		# Stores value into memory location
	pop BC;		# Gets Counter back off the stack.
	pop HL;		# Gets Write_Head back off the stack.
	# Current tracer registers:
		# A = ???; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Write_Head; 1
		# L = Write_Head; 1
	HL++;		# Increments Write_Head
	# Current tracer registers:
		# A = ???; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Write_Head; 1
		# L = Write_Head; 1
	DE++;		# Increments Read_Head
	# Current tracer registers:
		# A = ???; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Write_Head; 1
		# L = Write_Head; 1
	BC--;		# Decrements Counter
	A = B;		# Copies high byte of Counter into register
	push DE;		# Makes room by pushing Read_Head to stack.
	A = C;		# copies lower byte into A register
	A |= D;		# S_OR8
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__2_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = ???; 0
		# E = ???; 0
		# H = Write_Head; 1
		# L = Write_Head; 1
	# Register snapshot:
		# D = Read_Head; 1
		# H = Counter; 1
	D = H;		# Moves Write_Head into upper register
	E = L;		# Moves into lower register
	HL = SP + 0;		# Fetches Read_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	A = D;		# Temporarily stores value here
	D = H;		# Moves value into expected register
	H = A;		# Swaps temporarily value
	A = E;		# Temporarily stores value here
	E = L;		# Moves value into expected register
	L = A;		# Swaps temporarily value
	SP += $02;		# Fixes 'panic' push
	A = H;		# Temporarily stores value here
	H = B;		# Moves value into expected register
	B = A;		# Swaps temporarily value
	A = L;		# Temporarily stores value here
	L = C;		# Moves value into expected register
	C = A;		# Swaps temporarily value
	jump __do_while_statement__2;		# do/while loop jump
	label __do_while_statement__2_memory_cleanup;
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = ???; 0
		# E = ???; 0
		# H = Write_Head; 1
		# L = Write_Head; 1
	# Register snapshot:
		# D = Read_Head; 1
		# H = Counter; 1
	D = H;		# Moves Write_Head into upper register
	E = L;		# Moves into lower register
	HL = SP + 0;		# Fetches Read_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	A = D;		# Temporarily stores value here
	D = H;		# Moves value into expected register
	H = A;		# Swaps temporarily value
	A = E;		# Temporarily stores value here
	E = L;		# Moves value into expected register
	L = A;		# Swaps temporarily value
	SP += $02;		# Fixes 'panic' push
	A = H;		# Temporarily stores value here
	H = B;		# Moves value into expected register
	B = A;		# Swaps temporarily value
	A = L;		# Temporarily stores value here
	L = C;		# Moves value into expected register
	C = A;		# Swaps temporarily value


	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1
	# Register snapshot:
		# D = Read_Head; 1
		# H = Counter; 1
	label __if_statement__1;		# If statement label

	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1
	A = 1;
	return;
}

subroutine init_console_handle
{
	# Current tracer registers:
		# A = ; 0
		# B = Write_Head; 0
		# C = Write_Head; 0
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Counter; 0
		# L = Counter; 0
	BC = 0;
	HL = SP + 2;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	[HL] = 0; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = SP + 2;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL++;		# Increments Console_Handle
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 1
		# L = Console_Handle; 1
	B = H;		# Makes 'H' a copy of Console_Handle
	C = L;		# Makes 'L' a copy of L
	[HL] = 0; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	BC++;		# Increments Console_Handle
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	H = B;		# Creates copy of Console_Handle
	L = C;		# Creates copy of Console_Handle
	[HL] = $9800; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	DE = $9800;
	H = B;		# Creates copy of Console_Handle
	L = C;		# Creates copy of Console_Handle
	[HL] = D; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = ; 0
		# E = ; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	return;
}

subroutine printf
{
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 0
		# C = Console_Handle; 0
		# D = ; 0
		# E = ; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	SP += 254;		# byte* Write_Pointer;
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 0
		# C = Console_Handle; 0
		# D = ; 0
		# E = ; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	BC = $02;
	HL = SP + 6;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	A = [HL];		# Dereferences address
	HL = SP + 0;		# Fetches Write_Pointer off the stack
	B = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = B;		# Move lower byte from temp register
	L = A;		# Moves value into low-byte of Write_Pointer
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ; 0
		# D = ; 0
		# E = ; 0
		# H = Write_Pointer; 1
		# L = Write_Pointer; 1
	BC = $03;
	D = H;		# Moves Write_Pointer into upper register
	E = L;		# Moves into lower register
	HL = SP + 6;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	A = [HL];		# Dereferences address
	D = A;		# Moves value into high-byte of Write_Pointer
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = SP + 4;		# Fetches String off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	B = D;		# Makes 'H' a copy of Write_Pointer
	C = E;		# Makes 'L' a copy of E
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1

	label __do_while_statement__3;		# do/while loop label
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	A = [HL];		# Dereferences address
	B = H;		# Moves String into upper register
	C = L;		# Moves into lower register
	H = D;		# Creates copy of Write_Pointer
	L = E;		# Creates copy of Write_Pointer
	[HL] = A; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Write_Pointer; 0
		# L = Write_Pointer; 0
	DE++;		# Increments Write_Pointer
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Write_Pointer; 0
		# L = Write_Pointer; 0
	BC++;		# Increments String
	H = B;		# Creates copy of String
	L = C;		# Creates copy of String
	A = [HL];		# Dereferences address
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__3_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 0
		# L = String; 0
	# Register snapshot:
		# D = Write_Pointer; 1
		# H = String; 1
	H = B;		# Moves value into expected register
	L = C;		# Moves value into expected register
	jump __do_while_statement__3;		# do/while loop jump
	label __do_while_statement__3_memory_cleanup;
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 0
		# L = String; 0
	# Register snapshot:
		# D = Write_Pointer; 1
		# H = String; 1
	H = B;		# Moves value into expected register
	L = C;		# Moves value into expected register


	# Current tracer registers:
		# A = ???; 0
		# B = String; 0
		# C = String; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	A = 224;
	A &= E;		# S_AND8
	E = A;		# Moves value into low-byte of Write_Pointer
	# Current tracer registers:
		# A = ; 0
		# B = String; 0
		# C = String; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	BC = 32;
	push HL;		# Makes room by pushing String to stack.
	H = D;		# Creates copy of Write_Pointer
	L = E;		# Creates copy of Write_Pointer
	HL += BC;		# S_PLUS16
	pop BC;		# Gets String back off the stack.
	# Current tracer registers:
		# A = ; 0
		# B = String; 1
		# C = String; 1
		# D = ???; 0
		# E = ???; 0
		# H = Write_Pointer; 1
		# L = Write_Pointer; 1
	DE = $02;
	push BC;		# Makes room by pushing String to stack.
	B = H;		# Moves @statement_value@ into upper register
	C = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += DE;		# S_PLUS16
	[HL] = C; 		# Stores value into memory location
	pop DE;		# Gets String back off the stack.
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Pointer; 1
		# C = Write_Pointer; 1
		# D = String; 1
		# E = String; 1
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = $03;
	push DE;		# Makes room by pushing String to stack.
	D = H;		# Moves  into upper register
	E = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += DE;		# S_PLUS16
	[HL] = B; 		# Stores value into memory location
	pop DE;		# Gets String back off the stack.
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Pointer; 1
		# C = Write_Pointer; 1
		# D = String; 1
		# E = String; 1
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	SP += 2;		# Remove local variables from stack
	return;
}

subroutine Draw_Player_Sprite
{
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Pointer; 0
		# C = Write_Pointer; 0
		# D = String; 0
		# E = String; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	SP += 254;		# byte* Spritechain;
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Pointer; 0
		# C = Write_Pointer; 0
		# D = String; 0
		# E = String; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	SP += 255;		# byte Spritecount;
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Pointer; 0
		# C = Write_Pointer; 0
		# D = String; 0
		# E = String; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Pointer; 0
		# C = Write_Pointer; 0
		# D = String; 0
		# E = String; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	BC = $04;
	HL = SP + 7;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = String; 0
		# E = String; 0
		# H = Spritechain; 1
		# L = Spritechain; 1
	B = H;		# Moves Spritechain into upper register
	C = L;		# Moves into lower register
	HL = SP + -1;		# Memory location of Spritechain
	[HL] = C;		# Stores Spritechain back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Spritechain back into memory
	HL = SP + 1;		# Fetches Spritechain off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	A = [HL];		# Dereferences address
	A <<= 1;
	B = $00;		# Zeroes high byte
	C = A;		# Copies lower byte
	D = H;		# Moves Spritechain into upper register
	E = L;		# Moves into lower register
	HL = __Draw_Player_Sprite__Sprite_Chains;
	HL += BC;		# S_PLUS16
	push HL;		# Pushes address to the stack
	call load_16;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = @word@; 0
		# C = @word@; 0
		# D = Spritechain; 0
		# E = Spritechain; 0
		# H = Spritechain; 1
		# L = Spritechain; 1
	A = 9;
	# Current tracer registers:
		# A = Spritecount; 1
		# B = @word@; 0
		# C = @word@; 0
		# D = Spritechain; 0
		# E = Spritechain; 0
		# H = Spritechain; 1
		# L = Spritechain; 1
	B = H;		# Moves Spritechain into upper register
	C = L;		# Moves into lower register
	HL = SP + 0;		# Memory location of Spritecount
	[HL] = A;		# Stores Spritecount back into memory
	HL = SP + 1;		# Memory location of Spritechain
	[HL] = C;		# Stores Spritechain back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Spritechain back into memory
	HL = SP + 1;		# Fetches Spritechain off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Spritechain to the stack
	B = H;		# Moves Spritechain into upper register
	C = L;		# Moves into lower register
	HL = SP + 2;		# Fetches Spritecount off the stack
	A = [HL];		# Stores Spritecount into A register
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = A;		# Writes Count to stack
	SP = HL;		# Update stack pointer
	HL = SP + 8;		# Fetches Screen_Y off the stack
	D = [HL];		# Stores Screen_Y into D register
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = D;		# Writes Y to stack
	SP = HL;		# Update stack pointer
	HL = SP + 10;		# Fetches Screen_X off the stack
	E = [HL];		# Stores Screen_X into E register
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = E;		# Writes X to stack
	SP = HL;		# Update stack pointer
	call place_spritechain_in_oam_buffer;		# Calls function
	SP += 5;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = Spritecount; 0
		# B = Spritechain; 0
		# C = Spritechain; 0
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	SP += 3;		# Remove local variables from stack
	return;
}

subroutine Render_Player
{
	# Current tracer registers:
		# A = Spritecount; 0
		# B = Spritechain; 0
		# C = Spritechain; 0
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	SP += 255;		# byte Screen_X;
	# Current tracer registers:
		# A = Spritecount; 0
		# B = Spritechain; 0
		# C = Spritechain; 0
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	SP += 255;		# byte Screen_Y;
	# Current tracer registers:
		# A = Spritecount; 0
		# B = Spritechain; 0
		# C = Spritechain; 0
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	SP += 254;		# word Position;
	# Current tracer registers:
		# A = Spritecount; 0
		# B = Spritechain; 0
		# C = Spritechain; 0
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	HL = SP + 10;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes address to the stack
	call load_16;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Spritechain; 0
		# C = Spritechain; 0
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = Position; 1
		# L = Position; 1
	B = H;		# Moves Position into upper register
	C = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Position; 1
		# C = Position; 1
		# D = Screen_Y; 0
		# E = Screen_X; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	D = H;		# Moves Camera_X into upper register
	E = L;		# Moves into lower register
	HL = SP + 0;		# Memory location of Position
	[HL] = C;		# Stores Position back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Position back into memory
	HL = SP + 8;		# Memory location of Camera_X
	[HL] = E;		# Stores Camera_X back into memory
	HL++;
	[HL] = D;		# Stores upper byte of Camera_X back into memory
	HL = SP + 0;		# Fetches Position off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Left to the stack
	B = H;		# Moves Position into upper register
	C = L;		# Moves into lower register
	HL = SP + 10;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Right to the stack
	call sub16;		# Calls function
	SP += 4;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Position; 0
		# C = Position; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	B = H;		# Moves Camera_X into upper register
	C = L;		# Moves into lower register
	HL = SP + 6;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_X; 1
		# C = Camera_X; 1
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Camera_Y; 1
		# L = Camera_Y; 1
	D = H;		# Moves Camera_Y into upper register
	E = L;		# Moves into lower register
	HL = SP + 8;		# Memory location of Camera_X
	[HL] = C;		# Stores Camera_X back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_X back into memory
	HL = SP + 6;		# Memory location of Camera_Y
	[HL] = E;		# Stores Camera_Y back into memory
	HL++;
	[HL] = D;		# Stores upper byte of Camera_Y back into memory
	BC = $02;
	HL = SP + 10;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	push HL;		# Pushes address to the stack
	call load_16;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_Y; 0
		# E = Camera_Y; 0
		# H = Position; 1
		# L = Position; 1
	B = H;		# Moves Position into upper register
	C = L;		# Moves into lower register
	HL = SP + -1;		# Memory location of Position
	[HL] = C;		# Stores Position back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Position back into memory
	HL = SP + 0;		# Fetches Position off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Left to the stack
	B = H;		# Moves Position into upper register
	C = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Right to the stack
	call sub16;		# Calls function
	SP += 4;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Position; 0
		# C = Position; 0
		# D = Camera_Y; 0
		# E = Camera_Y; 0
		# H = Camera_Y; 1
		# L = Camera_Y; 1
	B = H;		# Moves Camera_Y into upper register
	C = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_Y; 1
		# C = Camera_Y; 1
		# D = Camera_Y; 0
		# E = Camera_Y; 0
		# H = Screen_X; 1
		# L = Camera_X; 0
	D = H;		# Moves Screen_X into upper register
	E = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	L <<= 1;
	H <<>|= 1;
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_Y; 1
		# C = Camera_Y; 1
		# D = Screen_X; 1
		# E = Camera_X; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	push HL;		# Makes room by pushing Camera_X to stack.
	HL = SP + 8;		# Memory location of Camera_Y
	[HL] = C;		# Stores Camera_Y back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_Y back into memory
	pop BC;		# Gets Camera_X back off the stack.
	HL = SP + 8;		# Memory location of Camera_X
	[HL] = C;		# Stores Camera_X back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_X back into memory
	HL = SP + 8;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes value to the stack
	call abs_16;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_X; 0
		# C = Camera_X; 0
		# D = Screen_X; 0
		# E = Camera_X; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	B = H;		# Moves Camera_X into upper register
	C = L;		# Moves into lower register
	HL = SP + 6;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_X; 1
		# C = Camera_X; 1
		# D = Screen_X; 0
		# E = Camera_X; 0
		# H = Screen_Y; 1
		# L = Camera_Y; 0
	D = H;		# Moves Screen_Y into upper register
	E = L;		# Moves into lower register
	HL = SP + 6;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	L <<= 1;
	H <<>|= 1;
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_X; 1
		# C = Camera_X; 1
		# D = Screen_Y; 1
		# E = Camera_Y; 0
		# H = Camera_Y; 1
		# L = Camera_Y; 1
	push HL;		# Makes room by pushing Camera_Y to stack.
	HL = SP + 10;		# Memory location of Camera_X
	[HL] = C;		# Stores Camera_X back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_X back into memory
	pop BC;		# Gets Camera_Y back off the stack.
	HL = SP + 6;		# Memory location of Camera_Y
	[HL] = C;		# Stores Camera_Y back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_Y back into memory
	HL = SP + 6;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes value to the stack
	call abs_16;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_Y; 0
		# C = Camera_Y; 0
		# D = Screen_Y; 0
		# E = Camera_Y; 0
		# H = Camera_Y; 1
		# L = Camera_Y; 1
	SP += 255;		# byte Condition;
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_Y; 0
		# C = Camera_Y; 0
		# D = Screen_Y; 0
		# E = Camera_Y; 0
		# H = Camera_Y; 1
		# L = Camera_Y; 1
	B = H;		# Moves Camera_Y into upper register
	C = L;		# Moves into lower register
	HL = SP + 9;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	A = H;		# Copies high byte of Camera_X into register
	# Current tracer registers:
		# A = Condition; 1
		# B = Camera_Y; 1
		# C = Camera_Y; 1
		# D = Screen_Y; 0
		# E = Camera_Y; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	D = B;		# Copies high byte of Camera_Y into register
	E = A;		# Makes 'A' a copy of Condition
	A |= D;		# S_OR8
	# Current tracer registers:
		# A = Condition; 1
		# B = Camera_Y; 1
		# C = Camera_Y; 1
		# D = ???; 0
		# E = ???; 0
		# H = Camera_X; 1
		# L = Camera_X; 1

	D = A;		# Makes 'A' a copy of Condition
	A |= A;		# This just gets the CPU flags
	jump not_zero __if_statement__4;		# If statement jump
	# Current tracer registers:
		# A = Condition; 0
		# B = Camera_Y; 1
		# C = Camera_Y; 1
		# D = Condition; 1
		# E = ???; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	push HL;		# Makes room by pushing Camera_X to stack.
	HL = SP + 9;		# Memory location of Camera_Y
	[HL] = C;		# Stores Camera_Y back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_Y back into memory
	pop BC;		# Gets Camera_X back off the stack.
	HL = SP + 9;		# Memory location of Camera_X
	[HL] = C;		# Stores Camera_X back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_X back into memory
	HL = SP + 11;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Player_Data to the stack
	B = H;		# Moves Player_Data into upper register
	C = L;		# Moves into lower register
	HL = SP + 6;		# Fetches Screen_X off the stack
	A = [HL];		# Store value into 'A' register
	A += 88;		# S_PLUS8
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = A;		# Writes Screen_X to stack
	SP = HL;		# Update stack pointer
	HL = SP + 6;		# Fetches Screen_Y off the stack
	A = [HL];		# Store value into 'A' register
	A += 88;		# S_PLUS8
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = A;		# Writes Screen_Y to stack
	SP = HL;		# Update stack pointer
	call Draw_Player_Sprite;		# Calls function
	SP += 4;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = Screen_Y; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Screen_X; 0
		# E = ???; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	# Register snapshot:
		# B = Camera_Y; 1
		# D = Condition; 1
		# H = Camera_X; 1
	HL = SP + 7;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	B = H;		# Moves value into expected register
	C = L;		# Moves value into expected register
	HL = SP + 0;		# Fetches Condition off the stack
	A = [HL];		# Stores Condition into A register
	D = A;		# Moves value into expected register
	HL = SP + 9;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	label __if_statement__4;		# If statement label

	# Current tracer registers:
		# A = ???; 0
		# B = Camera_Y; 1
		# C = Camera_Y; 1
		# D = Condition; 1
		# E = ???; 0
		# H = Camera_X; 1
		# L = Camera_X; 1
	SP += 5;		# Remove local variables from stack
	return;
}

subroutine Get_Controller_Inputs
{
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_Y; 0
		# C = Camera_Y; 0
		# D = Condition; 0
		# E = ???; 0
		# H = Camera_X; 0
		# L = Camera_X; 0
	HL = SP + 2;		# Fetches Flag off the stack
	A = [HL];		# Stores Flag into A register
	HL = $FF00;
	[HL] = A; 		# Stores value into memory location
	# Current tracer registers:
		# A = Flag; 1
		# B = Camera_Y; 0
		# C = Camera_Y; 0
		# D = Condition; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	SP += 255;		# byte Value_Back;
	# Current tracer registers:
		# A = Flag; 1
		# B = Camera_Y; 0
		# C = Camera_Y; 0
		# D = Condition; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	HL = $FF00;
	B = [HL];		# Dereferences address
	# Current tracer registers:
		# A = Flag; 1
		# B = Value_Back; 1
		# C = Camera_Y; 0
		# D = Condition; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	HL = $FF00;
	C = [HL];		# Dereferences address
	# Current tracer registers:
		# A = Flag; 1
		# B = ???; 0
		# C = Value_Back; 1
		# D = Condition; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	HL = $FF00;
	B = [HL];		# Dereferences address
	# Current tracer registers:
		# A = Flag; 1
		# B = Value_Back; 1
		# C = ???; 0
		# D = Condition; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	A = B;		# creates copy of Value_Back register
	SP += 1;		# Remove local variables from stack
	return;
}

subroutine Set_Player_State
{
	# Current tracer registers:
		# A = Value_Back; 0
		# B = Value_Back; 0
		# C = Flag; 0
		# D = Condition; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	HL = SP + 2;		# Fetches State off the stack
	A = [HL];		# Stores State into A register
	BC = $04;
	HL = SP + 3;		# Fetches Player_Data off the stack
	D = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = D;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	[HL] = A; 		# Stores value into memory location
	# Current tracer registers:
		# A = State; 1
		# B = ; 0
		# C = ; 0
		# D = ???; 0
		# E = ???; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	return;
}

subroutine Move_Player
{
	# Current tracer registers:
		# A = State; 0
		# B = ; 0
		# C = ; 0
		# D = ???; 0
		# E = ???; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	SP += 254;		# word Player_X;
	# Current tracer registers:
		# A = State; 0
		# B = ; 0
		# C = ; 0
		# D = ???; 0
		# E = ???; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	SP += 255;		# byte Inputs;
	# Current tracer registers:
		# A = State; 0
		# B = ; 0
		# C = ; 0
		# D = ???; 0
		# E = ???; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	A = $E0;
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = A;		# Writes Flag to stack
	SP = HL;		# Update stack pointer
	call Get_Controller_Inputs;		# Calls function
	SP += 1;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = Inputs; 1
		# B = ; 0
		# C = ; 0
		# D = ???; 0
		# E = ???; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	HL = SP + 0;		# Memory location of Inputs
	[HL] = A;		# Stores Inputs back into memory
	HL = SP + 5;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes address to the stack
	call load_16;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = ???; 0
		# E = ???; 0
		# H = Player_X; 1
		# L = Player_X; 1

	B = H;		# Moves Player_X into upper register
	C = L;		# Moves into lower register
	HL = SP + 0;		# Fetches Inputs off the stack
	A = [HL];		# Stores Inputs into A register
	A.CONTROLLER_LEFT_BIT;		# Gets conditional
	jump not_zero __if_statement__5;		# If statement jump
	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ???; 0
		# E = ???; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	BC--;		# Decrements Player_X
	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ???; 0
		# E = ???; 0
		# H = @@stack_pointer@@; 0
		# L = @@stack_pointer@@; 0
	DE = $04;
	push BC;		# Makes room by pushing Player_X to stack.
	HL = SP + 7;		# Fetches Player_Data off the stack
	B = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = B;		# Move lower byte from temp register
	HL += DE;		# S_PLUS16
	[HL] = 1; 		# Stores value into memory location
	pop BC;		# Gets Player_X back off the stack.
	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	# Register snapshot:
		# A = Inputs; 1
		# B = Player_X; 1
	label __if_statement__5;		# If statement label

	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0

	A.CONTROLLER_RIGHT_BIT;		# Gets conditional
	jump not_zero __if_statement__6;		# If statement jump
	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	BC++;		# Increments Player_X
	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	DE = $04;
	push BC;		# Makes room by pushing Player_X to stack.
	HL = SP + 7;		# Fetches Player_Data off the stack
	B = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = B;		# Move lower byte from temp register
	HL += DE;		# S_PLUS16
	[HL] = 0; 		# Stores value into memory location
	pop BC;		# Gets Player_X back off the stack.
	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	# Register snapshot:
		# A = Inputs; 1
		# B = Player_X; 1
	label __if_statement__6;		# If statement label

	# Current tracer registers:
		# A = Inputs; 1
		# B = Player_X; 1
		# C = Player_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	HL = SP + 0;		# Memory location of Inputs
	[HL] = A;		# Stores Inputs back into memory
	HL = SP + 1;		# Memory location of Player_X
	[HL] = C;		# Stores Player_X back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Player_X back into memory
	HL = SP + 5;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes address to the stack
	B = H;		# Moves Player_Data into upper register
	C = L;		# Moves into lower register
	HL = SP + 3;		# Fetches Player_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes value to the stack
	call write_16;		# Calls function
	SP += 4;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = ; 0
		# E = ; 0
		# H = Player_X; 0
		# L = Player_X; 0
	SP += 3;		# Remove local variables from stack
	return;
}

subroutine Test_Game_Loop
{
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = ; 0
		# E = ; 0
		# H = Player_X; 0
		# L = Player_X; 0
	SP += 254;		# byte* Player_Data;
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = ; 0
		# E = ; 0
		# H = Player_X; 0
		# L = Player_X; 0
	SP += 254;		# word Camera_X;
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = ; 0
		# E = ; 0
		# H = Player_X; 0
		# L = Player_X; 0
	SP += 254;		# word Camera_Y;
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = ; 0
		# E = ; 0
		# H = Player_X; 0
		# L = Player_X; 0
	BC = 0;
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_X; 1
		# C = Camera_X; 1
		# D = ; 0
		# E = ; 0
		# H = Player_X; 0
		# L = Player_X; 0
	DE = 0;
	# Current tracer registers:
		# A = ???; 0
		# B = Camera_X; 1
		# C = Camera_X; 1
		# D = Camera_Y; 1
		# E = Camera_Y; 1
		# H = Player_X; 0
		# L = Player_X; 0
	HL = SP + 2;		# Memory location of Camera_X
	[HL] = C;		# Stores Camera_X back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Camera_X back into memory
	HL = SP + 0;		# Memory location of Camera_Y
	[HL] = E;		# Stores Camera_Y back into memory
	HL++;
	[HL] = D;		# Stores upper byte of Camera_Y back into memory
	BC = $08;
	push BC;		# Pushes size to the stack
	call malloc;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_Y; 0
		# E = Camera_Y; 0
		# H = Player_Data; 1
		# L = Player_Data; 1
	B = H;		# Moves Player_Data into upper register
	C = L;		# Moves into lower register
	HL = SP + -1;		# Memory location of Player_Data
	[HL] = C;		# Stores Player_Data back into memory
	HL++;
	[HL] = B;		# Stores upper byte of Player_Data back into memory
	HL = SP + 4;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Destination to the stack
	A = 0;
	B = H;		# Moves Player_Data into upper register
	C = L;		# Moves into lower register
	HL = SP + 255;		# Makes room on stack for 1 byte
	[HL] = A;		# Writes Value to stack
	SP = HL;		# Update stack pointer
	DE = $08;
	push DE;		# Pushes Count to the stack
	call memset;		# Calls function
	SP += 5;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = @parameter@; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = ; 0
		# E = ; 0
		# H = ???; 0
		# L = ???; 0
	BC = $02;
	HL = SP + 4;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	push HL;		# Pushes address to the stack
	BC = $30;
	push BC;		# Pushes value to the stack
	call write_16;		# Calls function
	SP += 4;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0

	label __do_while_statement__7;		# do/while loop label
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	call Clean_OAM_Buffer;		# Calls function
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = ; 0
		# E = ; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	HL = SP + 4;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Player_Data to the stack
	B = H;		# Moves Player_Data into upper register
	C = L;		# Moves into lower register
	HL = SP + 4;		# Fetches Camera_X off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Camera_X to the stack
	D = H;		# Moves Camera_X into upper register
	E = L;		# Moves into lower register
	HL = SP + 4;		# Fetches Camera_Y off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Camera_Y to the stack
	call Render_Player;		# Calls function
	SP += 6;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Camera_Y; 0
		# L = Camera_Y; 0
	call Wait_For_VBlank;		# Calls function
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Camera_Y; 0
		# L = Camera_Y; 0
	call dma_transfer;		# Calls function
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Camera_Y; 0
		# L = Camera_Y; 0
	HL = SP + 4;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes Player_Data to the stack
	call Move_Player;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	A = 1;
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__7_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = ; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	# Register snapshot:
	jump __do_while_statement__7;		# do/while loop jump
	label __do_while_statement__7_memory_cleanup;
	# Current tracer registers:
		# A = ; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	# Register snapshot:


	# Current tracer registers:
		# A = ; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	HL = SP + 4;		# Fetches Player_Data off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	push HL;		# Pushes address to the stack
	call free;		# Calls function
	SP += 2;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	SP += 6;		# Remove local variables from stack
	return;
}

subroutine main
{
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	call Wait_For_VBlank;		# Calls function
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = Player_Data; 0
		# L = Player_Data; 0
	HL = $FF40;
	[HL] = 0; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Player_Data; 0
		# C = Player_Data; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	BC = $8000;
	push BC;		# Pushes Write_Head to the stack
	BC = main;
	push BC;		# Pushes Read_Head to the stack
	BC = $800;
	push BC;		# Pushes Counter to the stack
	call Conditional_Checker;		# Calls function
	SP += 6;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	BC = $8800;
	push BC;		# Pushes Write_Head to the stack
	BC = __main__Test;
	push BC;		# Pushes Read_Head to the stack
	BC = 17;
	push BC;		# Pushes Counter to the stack
	call Conditional_Checker;		# Calls function
	SP += 6;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	HL = $FF40;
	[HL] = $83; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0

	A = 1;
	A |= A;		# This just gets the CPU flags
	jump zero __if_statement__8;		# If statement jump
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0

	label __do_while_statement__9;		# do/while loop label
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	call Wait_For_VBlank;		# Calls function
	A = 1;
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__9_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:
	jump __do_while_statement__9;		# do/while loop jump
	label __do_while_statement__9_memory_cleanup;
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:


	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:
	label __if_statement__8;		# If statement label

	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Camera_X; 0
		# E = Camera_X; 0
		# H = ; 0
		# L = ; 0
	return;
}

data Box_Bot_Graphics
{
	$00 $01 $01 $02 $01 $1E $00 $1F $00 $0D $00 
	$00 $00 $00 $00 $00 $00 $FF $F7 $0E $EF 
	$1F $EF $1F $07 $FE $F0 $FF $38 $38 $18 
	$18 $00 $F8 $F8 $1C $FC $3E $FC $3E $F8 
	$1C $00 $F8 $00 $00 $00 $00 $00 $0F $07 
	$18 $0C $13 $0B $17 $0B $17 $0C $13 $0F 
	$10 $0F $10 $00 $FF $E7 $18 $EF $10 $FF 
	$FE $FF $FF $EF $13 $EF $10 $EF $10 $00 
	$F0 $E0 $18 $F0 $08 $F6 $0E $F7 $0F $F3 
	$0B $F0 $08 $F0 $08 $1F $1C $23 $3F $3A 
	$2D $4F $7F $9F $FF $DF $BF $C8 $F7 $7F 
	$7F $EF $10 $E7 $98 $7B $FC $24 $DF $F3 
	$FF $F6 $FB $44 $BF $FB $FB $F0 $08 $E0 
	$18 $CC $3C $12 $FE $E1 $FF $01 $FF $02 
	$FE $FC $FC $00 $FF $E7 $18 $EF $10 $EF 
	$F0 $FF $FE $FF $3F $EF $13 $EF $10 $00 
	$F0 $E0 $18 $F0 $08 $F0 $08 $F6 $0E $F7 
	$0F $F3 $0B $F0 $08 $00 $FF $E7 $18 $EF 
	$10 $EF $90 $FF $F0 $FF $FE $FF $1F $EF 
	$13 $00 $F0 $E0 $18 $F0 $08 $F0 $08 $F0 
	$08 $F6 $0E $F7 $0F $F3 $0B $00 $FF $E7 
	$18 $EF $10 $EF $90 $EF $F0 $FF $F8 $FF 
	$3E $EF $1E $00 $F0 $E0 $18 $F0 $08 $F0 
	$08 $F0 $08 $F4 $0C $F7 $0F $F7 $0F $EF 
	$16 $E7 $98 $7B $FC $24 $DF $F3 $FF $F6 
	$FB $44 $BF $FB $FB $F3 $0B $E0 $18 $CC 
	$3C $12 $FE $E1 $FF $01 $FF $02 $FE $FC 
	$FC $1F $1C $23 $3F $2C $3B $5F $6F $9F 
	$FF $BF $DF $C4 $FB $7F $7F $EF $16 $E7 
	$98 $7B $FC $44 $BF $F7 $FB $F2 $FF $24 
	$DF $FB $FB $1F $1C $27 $3B $28 $3F $6F 
	$5F $9F $FF $9F $FF $E2 $DD $7F $7F $EF 
	$16 $E7 $98 $7B $FC $84 $7F $FB $F7 $F2 
	$FF $14 $EF $FB $FB $1F $1C $2B $37 $28 
	$3F $4F $7F $BF $DF $9F $FF $D1 $EE $7F 
	$7F $EF $16 $E7 $98 $FB $7C $0C $F7 $F3 
	$FF $F2 $FF $0C $F7 $FB $FB $00 $FF $EF 
	$1C $DF $3E $DF $3E $0F $FC $E0 $FF $38 
	$38 $18 $18 $00 $0F $07 $18 $0C $13 $0B 
	$17 $0B $17 $0C $13 $0F $10 $0F $10 $00 
	$FF $CF $30 $DF $20 $FF $FC $FF $FF $DF 
	$27 $DF $20 $DF $20 $00 $F0 $E0 $18 $F0 
	$08 $F6 $0E $F7 $0F $F3 $0B $F0 $08 $F0 
	$08 $1F $1C $23 $3F $3A $2D $4F $7F $9F 
	$FF $DF $BF $C8 $F7 $7F $7F $DF $20 $CF 
	$B0 $77 $F8 $08 $FF $E7 $FF $EC $F7 $48 
	$BF $F7 $F7 $00 $FF $DF $38 $BF $7C $BF 
	$7C $1F $F8 $C0 $FF $38 $38 $18 $18 $00 
	$F0 $F0 $38 $F8 $7C $F8 $7C $F0 $38 $00 
	$F0 $00 $00 $00 $00 $00 $0F $07 $18 $0C 
	$13 $0B $17 $0B $17 $0C $13 $0F $10 $0F 
	$10 $00 $FF $9F $60 $BF $40 $FF $F8 $FF 
	$FE $BF $4E $BF $40 $BF $40 $00 $F0 $E0 
	$18 $F0 $08 $F6 $0E $F7 $0F $F3 $0B $F0 
	$08 $F0 $08 $3F $3C $43 $7F $7A $5D $9F 
	$FF $BF $FF $FF $BF $C8 $F7 $7F $7F $BF 
	$40 $9F $E0 $6F $F0 $10 $FF $CF $FF $D8 
	$EF $50 $BF $EF $EF $00 $01 $01 $02 $01 
	$1E $00 $1F $00 $0D $00 $00 $00 $00 $00 
	$00 $00 $FF $BF $70 $7F $F8 $7F $F8 $3F 
	$F0 $80 $FF $70 $70 $30 $30 $00 $E0 $E0 
	$70 $F0 $F8 $F0 $F8 $E0 $70 $00 $E0 $00 
	$00 $00 $00 $00 $0F $07 $18 $0C $13 $0B 
	$17 $0B $17 $0C $13 $0F $10 $0F $10 $00 
	$FF $3F $C0 $7F $80 $FF $F0 $FF $FC $7F 
	$9C $7F $80 $7F $80 $00 $E0 $C0 $30 $E0 
	$10 $EC $1C $EE $1E $E6 $16 $E0 $10 $E0 
	$10 $3F $3E $41 $7F $7A $5D $9F $FF $BF 
	$FF $FF $BF $C8 $F7 $7F $7F $7F $80 $3F 
	$C0 $DF $E0 $20 $FF $9F $FF $D0 $BF $A0 
	$7F $DF $DF $E0 $10 $C0 $30 $98 $78 $24 
	$FC $C2 $FE $02 $FE $02 $FE $FC $FC $00 
	$01 $01 $02 $00 $0F $00 $0F $00 $05 $00 
	$00 $00 $00 $00 $00 $00 $FF $7F $E0 $FF 
	$F1 $FF $F1 $7F $E0 $00 $FF $70 $70 $30 
	$30 $00 $C0 $C0 $E0 $E0 $F0 $E0 $F0 $C0 
	$E0 $00 $C0 $00 $00 $00 $00 $00 $07 $02 
	$0D $00 $0F $07 $0F $07 $0F $00 $0F $06 
	$09 $06 $09 $00 $FF $7F $80 $FF $00 $FF 
	$E0 $FF $F8 $FF $38 $FF $00 $FF $00 $00 
	$C0 $80 $60 $C0 $20 $D8 $38 $DC $3C $CC 
	$2C $C0 $20 $C0 $20 $1E $1F $21 $3F $3D 
	$2E $4E $7F $5E $7F $7F $5E $64 $7B $3F 
	$3F $FF $00 $7F $80 $BF $C0 $40 $FF $3F 
	$FF $30 $FF $58 $DF $8F $8F $C0 $20 $80 
	$60 $30 $F0 $48 $F8 $84 $FC $04 $FC $04 
	$FC $F8 $F8 $00 $00 $00 $01 $00 $03 $00 
	$03 $00 $01 $00 $00 $00 $00 $00 $00 $00 
	$FF $7F $E1 $FF $F3 $FF $F3 $7F $E1 $00 
	$FF $38 $38 $18 $18 $00 $80 $80 $C0 $C0 
	$E0 $C0 $E0 $80 $C0 $00 $80 $00 $00 $00 
	$00 $00 $03 $02 $05 $00 $07 $03 $07 $03 
	$07 $00 $07 $02 $05 $02 $05 $00 $FF $7F 
	$80 $FF $00 $FF $C0 $FF $F0 $FF $30 $FF 
	$00 $FF $00 $00 $C0 $80 $60 $C0 $20 $D0 
	$30 $D8 $38 $D8 $38 $C0 $20 $C0 $20 $0E 
	$0F $11 $1F $1F $10 $2C $3F $2C $3F $3C 
	$2F $3F $30 $1F $1F $FF $00 $7F $80 $BF 
	$C0 $C0 $FF $4F $CF $48 $CF $C8 $4F $87 
	$87 $C0 $20 $80 $60 $30 $F0 $58 $E8 $84 
	$FC $04 $FC $0C $F4 $F8 $F8 $00 $01 $00 
	$03 $01 $03 $01 $03 $00 $03 $00 $01 $00 
	$00 $00 $00 $00 $FF $FF $C3 $FF $E7 $FF 
	$E7 $FF $C3 $00 $FF $3C $3C $18 $18 $00 
	$80 $00 $C0 $80 $C0 $80 $C0 $00 $C0 $00 
	$80 $00 $00 $00 $00 $00 $01 $00 $03 $01 
	$02 $07 $06 $07 $07 $03 $03 $01 $02 $01 
	$02 $00 $FF $FF $00 $FF $00 $FF $00 $FF 
	$00 $FF $00 $FF $00 $FF $00 $00 $80 $00 
	$C0 $80 $40 $E0 $60 $E0 $E0 $C0 $C0 $80 
	$40 $80 $40 $0D $0E $12 $1F $1F $11 $11 
	$1F $10 $1F $10 $1F $1F $10 $0F $0F $FF 
	$00 $FF $00 $7E $81 $81 $FF $81 $81 $81 
	$81 $81 $81 $00 $00 $B0 $70 $48 $F8 $F8 
	$88 $88 $F8 $08 $F8 $08 $F8 $F8 $08 $F0 
	$F0 $00 $00 $00 $00 $00 $00 $00 $00 $00 
	$00 $00 $00 $00 $1F $17 $EE $00 $00 $00 
	$00 $00 $00 $00 $00 $00 $00 $00 $00 $00 
	$F8 $F8 $1C $01 $02 $01 $1E $00 $1F $00 
	$0D $00 $00 $00 $00 $00 $00 $00 $0F $EF 
	$1F $EF $1F $E7 $1E $10 $FF $F0 $F0 $38 
	$38 $18 $18 $00 $FF $FC $3E $FC $3E $F8 
	$1C $00 $F8 $00 $00 $00 $00 $00 $00 $00 
	$F0 $07 $18 $0C $13 $0B $17 $0B $17 $0C 
	$13 $0F $10 $0F $10 $1F $1C $E7 $18 $EF 
	$10 $EF $90 $EF $F0 $FF $F8 $FF $3E $EF 
	$1E $EF $16 $E0 $18 $F0 $08 $F0 $08 $F0 
	$08 $F4 $0C $F7 $0F $F7 $0F $F3 $0B $23 
	$3F $3A $2D $4E $7F $9F $FF $DF $BF $51 
	$6F $3D $3E $03 $03 $E7 $18 $E3 $9C $40 
	$FF $7F $BF $98 $FF $CE $FF $19 $E9 $F0 
	$F0 $E0 $18 $C8 $38 $14 $FC $E2 $FE $01 
	$FF $01 $FF $C1 $FF $3E $3E $7E $7E $FF 
	$81 $DB $A5 $DB $A5 $EB $95 $F7 $89 $FB 
	$85 $C3 $BD $FF $81 $FF $81 $00 $FF $FF 
	$81 $00 $FF $FF $81 $FF $81 $FF $FF $70 
	$00 $FE $00 $EF $10 $CF $30 $76 $08 $78 
	$06 $78 $04 $30 $00 $70 $00 $FE $00 $E3 
	$1C $C1 $3E $40 $3E $00 $3E $00 $1C $00 
	$00 $00 $00 $00 $38 $00 $7C $02 $7C $02 
	$7C $06 $38 $1C $00 $00 $00 $00 $00 $00 
	$00 $00 $00 $00 $00
}

data Bot_Idle_Right
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $04 $00 251 
	3 $05 $00 3 243 $06 $00 3 251 $07 $00 3 
	3 $08 $00
}

data Bot_Idle_Left
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $05 $20 251 251 $04 $20 251 
	3 $03 $20 3 243 $08 $20 3 251 $07 $20 3 
	3 $06 $20
}

data Bot_Walk_Right_0
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $09 $00 251 
	3 $0A $00 3 243 $06 $00 3 251 $07 $00 3 
	3 $08 $00
}

data Bot_Walk_Left_0
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $0A $20 251 251 $09 $20 251 
	3 $03 $20 3 243 $08 $20 3 251 $07 $20 3 
	3 $06 $20
}

data Bot_Walk_Right_1
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $0B $00 251 
	3 $0C $00 3 243 $06 $00 3 251 $07 $00 3 
	3 $08 $00
}

data Bot_Walk_Left_1
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $0C $20 251 251 $0B $20 251 
	3 $03 $20 3 243 $08 $20 3 251 $07 $20 3 
	3 $06 $20
}

data Bot_Walk_Right_2
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $0D $00 251 
	3 $0E $00 3 243 $06 $00 3 251 $0F $00 3 
	3 $10 $00
}

data Bot_Walk_Left_2
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $0E $20 251 251 $0D $20 251 
	3 $03 $20 3 243 $10 $20 3 251 $0F $20 3 
	3 $06 $20
}

data Bot_Run_Right_0
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $0D $00 251 
	3 $0E $00 3 243 $11 $00 3 251 $12 $00 3 
	3 $10 $00
}

data Bot_Run_Left_0
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $0E $20 251 251 $0D $20 251 
	3 $03 $20 3 243 $10 $20 3 251 $12 $20 3 
	3 $11 $20
}

data Bot_Run_Right_1
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $0D $00 251 
	3 $0E $00 3 243 $13 $00 3 251 $14 $00 3 
	3 $10 $00
}

data Bot_Run_Left_1
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $0E $20 251 251 $0D $20 251 
	3 $03 $20 3 243 $10 $20 3 251 $14 $20 3 
	3 $13 $20
}

data Bot_Run_Right_2
{
	243 243 $00 $00 243 251 $01 $00 243 3 $02 
	$00 251 243 $03 $00 251 251 $0D $00 251 
	3 $0E $00 3 243 $15 $00 3 251 $16 $00 3 
	3 $10 $00
}

data Bot_Run_Left_2
{
	243 243 $02 $20 243 251 $01 $20 243 3 $00 
	$20 251 243 $0E $20 251 251 $0D $20 251 
	3 $03 $20 3 243 $10 $20 3 251 $16 $20 3 
	3 $15 $20
}

data Bot_Turn_Right_0
{
	243 243 $00 $00 243 251 $17 $00 243 3 $02 
	$00 251 243 $18 $00 251 251 $19 $00 251 
	3 $1A $00 3 243 $1B $00 3 251 $1C $00 3 
	3 $08 $00
}

data Bot_Turn_Left_0
{
	243 243 $02 $20 243 251 $17 $20 243 3 $00 
	$20 251 243 $1A $20 251 251 $19 $20 251 
	3 $18 $20 3 243 $08 $20 3 251 $1C $20 3 
	3 $1B $20
}

data Bot_Turn_Right_1
{
	243 243 $00 $00 243 251 $1D $00 243 3 $1E 
	$00 251 243 $1F $00 251 251 $20 $00 251 
	3 $21 $00 3 243 $22 $00 3 251 $23 $00 3 
	3 $08 $00
}

data Bot_Turn_Left_1
{
	243 243 $1E $20 243 251 $1D $20 243 3 $00 
	$20 251 243 $21 $20 251 251 $20 $20 251 
	3 $1F $20 3 243 $08 $20 3 251 $23 $20 3 
	3 $22 $20
}

data Bot_Turn_Right_2
{
	243 243 $24 $00 243 251 $25 $00 243 3 $26 
	$00 251 243 $27 $00 251 251 $28 $00 251 
	3 $29 $00 3 243 $2A $00 3 251 $2B $00 3 
	3 $2C $00
}

data Bot_Turn_Left_2
{
	243 243 $26 $20 243 251 $25 $20 243 3 $24 
	$20 251 243 $29 $20 251 251 $28 $20 251 
	3 $27 $20 3 243 $2C $20 3 251 $2B $20 3 
	3 $2A $20
}

data Bot_Turn_Right_3
{
	243 243 $2D $00 243 251 $2E $00 243 3 $2F 
	$00 251 243 $30 $00 251 251 $31 $00 251 
	3 $32 $00 3 243 $33 $00 3 251 $34 $00 3 
	3 $35 $00
}

data Bot_Turn_Left_3
{
	243 243 $2D $00 243 251 $2E $00 243 3 $2F 
	$00 251 243 $30 $00 251 251 $31 $00 251 
	3 $32 $00 3 243 $33 $00 3 251 $34 $00 3 
	3 $35 $00
}

data Bot_Turn_Right_4
{
	243 243 $36 $00 243 251 $37 $00 243 3 $38 
	$00 251 243 $39 $00 251 251 $3A $00 251 
	3 $3B $00 3 243 $3C $00 3 251 $3D $00 3 
	3 $3E $00
}

data Bot_Turn_Left_4
{
	243 243 $38 $20 243 251 $37 $20 243 3 $36 
	$20 251 243 $3B $20 251 251 $3A $20 251 
	3 $39 $20 3 243 $3E $20 3 251 $3D $20 3 
	3 $3C $20
}

data Bot_Turn_Middle
{
	243 243 $3F $00 243 251 $40 $00 243 3 $41 
	$00 251 243 $42 $00 251 251 $43 $00 251 
	3 $44 $00 3 243 $45 $00 3 251 $46 $00 3 
	3 $47 $00
}

data Bot_Jump_Right
{
	236 251 $48 $00 236 3 $49 $00 244 243 $4A 
	$00 244 251 $4B $00 244 3 $4C $00 252 243 
	$4D $00 252 251 $4E $00 252 3 $4F $00 4 
	243 $50 $00 4 251 $51 $00 4 3 $52 $00
}

data Bot_Jump_Left
{
	236 251 $48 $20 236 243 $49 $20 244 243 $4C 
	$20 244 251 $4B $20 244 3 $4A $20 252 243 
	$4F $20 252 251 $4E $20 252 3 $4D $20 4 
	243 $52 $20 4 251 $51 $20 4 3 $50 $20
}

data __Draw_Player_Sprite__Sprite_Chains
{
	Bot_Walk_Right_2 high(Bot_Walk_Right_2) Bot_Walk_Left_2 
	high(Bot_Walk_Left_2)
}

data __main__Test
{
	"HELLO! I AM TEXT" 0
}

