subroutine Wait_For_VBlank
{
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ???; 0
		# L = ???; 0
	SP += 255;		# byte Scanline;
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ???; 0
		# L = ???; 0

	label __do_while_statement__0;		# do/while loop label
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ???; 0
		# L = ???; 0
	HL = $FF44;
	A = [HL];		# Dereferences address
	A < $90;		# S_LESS_THAN8
	jump  not_carry __do_while_statement__0_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = Scanline; 1
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:
	jump __do_while_statement__0;		# do/while loop jump
	label __do_while_statement__0_memory_cleanup;
	# Current tracer registers:
		# A = Scanline; 1
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:


	# Current tracer registers:
		# A = Scanline; 1
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	SP += 1;		# Remove local variables from stack
	return;
}

subroutine Conditional_Checker
{
	# Current tracer registers:
		# A = Scanline; 0
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = ; 0
		# L = ; 0
	HL = SP + 6;		# Fetches Write_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = ???; 0
		# E = ???; 0
		# H = Write_Head; 1
		# L = Write_Head; 1
	B = H;		# Moves Write_Head into upper register
	C = L;		# Moves into lower register
	HL = SP + 4;		# Fetches Read_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = ???; 0
		# E = ???; 0
		# H = Read_Head; 1
		# L = Read_Head; 1
	D = H;		# Moves Read_Head into upper register
	E = L;		# Moves into lower register
	HL = SP + 2;		# Fetches Counter off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1

	A = H;		# Copies high byte of Counter into register
	push BC;		# Makes room by pushing Write_Head to stack.
	A = L;		# copies lower byte into A register
	A |= B;		# S_OR8
	A |= A;		# This just gets the CPU flags
	jump zero __if_statement__1;		# If statement jump
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = ???; 0
		# C = ???; 0
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1

	label __do_while_statement__2;		# do/while loop label
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = ???; 0
		# C = ???; 0
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1
	B = H;		# Moves Counter into upper register
	C = L;		# Moves into lower register
	H = D;		# Moves Read_Head
	L = E;		# Moves Read_Head
	A = [HL];		# Dereferences address
	D = H;		# Moves Read_Head into upper register
	E = L;		# Moves into lower register
	push BC;		# Makes room by pushing Counter to stack.
	HL = SP + 2;		# Fetches Write_Head off the stack
	B = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = B;		# Move lower byte from temp register
	[HL] = A; 		# Stores value into memory location
	pop BC;		# Gets Counter back off the stack.
	pop HL;		# Gets Write_Head back off the stack.
	# Current tracer registers:
		# A = ???; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Write_Head; 1
		# L = Write_Head; 1
	HL++;		# Increments Write_Head
	# Current tracer registers:
		# A = ???; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Write_Head; 1
		# L = Write_Head; 1
	DE++;		# Increments Read_Head
	# Current tracer registers:
		# A = ???; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Write_Head; 1
		# L = Write_Head; 1
	BC--;		# Decrements Counter
	A = B;		# Copies high byte of Counter into register
	push DE;		# Makes room by pushing Read_Head to stack.
	A = C;		# copies lower byte into A register
	A |= D;		# S_OR8
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__2_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = ???; 0
		# E = ???; 0
		# H = Write_Head; 1
		# L = Write_Head; 1
	# Register snapshot:
		# D = Read_Head; 1
		# H = Counter; 1
	D = H;		# Moves Write_Head into upper register
	E = L;		# Moves into lower register
	HL = SP + 0;		# Fetches Read_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	A = D;		# Temporarily stores value here
	D = H;		# Moves value into expected register
	H = A;		# Swaps temporarily value
	A = E;		# Temporarily stores value here
	E = L;		# Moves value into expected register
	L = A;		# Swaps temporarily value
	SP += $02;		# Fixes 'panic' push
	A = H;		# Temporarily stores value here
	H = B;		# Moves value into expected register
	B = A;		# Swaps temporarily value
	A = L;		# Temporarily stores value here
	L = C;		# Moves value into expected register
	C = A;		# Swaps temporarily value
	jump __do_while_statement__2;		# do/while loop jump
	label __do_while_statement__2_memory_cleanup;
	# Current tracer registers:
		# A = @lower_byte@; 0
		# B = Counter; 1
		# C = Counter; 1
		# D = ???; 0
		# E = ???; 0
		# H = Write_Head; 1
		# L = Write_Head; 1
	# Register snapshot:
		# D = Read_Head; 1
		# H = Counter; 1
	D = H;		# Moves Write_Head into upper register
	E = L;		# Moves into lower register
	HL = SP + 0;		# Fetches Read_Head off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	A = D;		# Temporarily stores value here
	D = H;		# Moves value into expected register
	H = A;		# Swaps temporarily value
	A = E;		# Temporarily stores value here
	E = L;		# Moves value into expected register
	L = A;		# Swaps temporarily value
	SP += $02;		# Fixes 'panic' push
	A = H;		# Temporarily stores value here
	H = B;		# Moves value into expected register
	B = A;		# Swaps temporarily value
	A = L;		# Temporarily stores value here
	L = C;		# Moves value into expected register
	C = A;		# Swaps temporarily value


	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1
	# Register snapshot:
		# D = Read_Head; 1
		# H = Counter; 1
	label __if_statement__1;		# If statement label

	# Current tracer registers:
		# A = ???; 0
		# B = Write_Head; 1
		# C = Write_Head; 1
		# D = Read_Head; 1
		# E = Read_Head; 1
		# H = Counter; 1
		# L = Counter; 1
	A = 1;
	return;
}

subroutine init_console_handle
{
	# Current tracer registers:
		# A = ; 0
		# B = Write_Head; 0
		# C = Write_Head; 0
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Counter; 0
		# L = Counter; 0
	BC = 0;
	HL = SP + 2;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	[HL] = 0; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = SP + 2;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL++;		# Increments Console_Handle
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 1
		# L = Console_Handle; 1
	B = H;		# Makes 'H' a copy of Console_Handle
	C = L;		# Makes 'L' a copy of L
	[HL] = 0; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	BC++;		# Increments Console_Handle
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	H = B;		# Creates copy of Console_Handle
	L = C;		# Creates copy of Console_Handle
	[HL] = $9800; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = Read_Head; 0
		# E = Read_Head; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	DE = $9800;
	H = B;		# Creates copy of Console_Handle
	L = C;		# Creates copy of Console_Handle
	[HL] = D; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 1
		# C = Console_Handle; 1
		# D = ; 0
		# E = ; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	return;
}

subroutine printf
{
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 0
		# C = Console_Handle; 0
		# D = ; 0
		# E = ; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	SP += 254;		# byte* Write_Pointer;
	# Current tracer registers:
		# A = ???; 0
		# B = Console_Handle; 0
		# C = Console_Handle; 0
		# D = ; 0
		# E = ; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	BC = $02;
	HL = SP + 6;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	A = [HL];		# Dereferences address
	HL = SP + 0;		# Fetches Write_Pointer off the stack
	B = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = B;		# Move lower byte from temp register
	L = A;		# Moves value into low-byte of Write_Pointer
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ; 0
		# D = ; 0
		# E = ; 0
		# H = Write_Pointer; 1
		# L = Write_Pointer; 1
	BC = $03;
	D = H;		# Moves Write_Pointer into upper register
	E = L;		# Moves into lower register
	HL = SP + 6;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	A = [HL];		# Dereferences address
	D = A;		# Moves value into high-byte of Write_Pointer
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = SP + 4;		# Fetches String off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	B = D;		# Makes 'H' a copy of Write_Pointer
	C = E;		# Makes 'L' a copy of E
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1

	label __do_while_statement__3;		# do/while loop label
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	A = [HL];		# Dereferences address
	B = H;		# Moves String into upper register
	C = L;		# Moves into lower register
	H = D;		# Creates copy of Write_Pointer
	L = E;		# Creates copy of Write_Pointer
	[HL] = A; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Write_Pointer; 0
		# L = Write_Pointer; 0
	DE++;		# Increments Write_Pointer
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Write_Pointer; 0
		# L = Write_Pointer; 0
	BC++;		# Increments String
	H = B;		# Moves String
	L = C;		# Moves String
	A = [HL];		# Dereferences address
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__3_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	# Register snapshot:
		# D = Write_Pointer; 1
		# H = String; 1
	jump __do_while_statement__3;		# do/while loop jump
	label __do_while_statement__3_memory_cleanup;
	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	# Register snapshot:
		# D = Write_Pointer; 1
		# H = String; 1


	# Current tracer registers:
		# A = ???; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	A = 224;
	A &= E;		# S_AND8
	E = A;		# Moves value into low-byte of Write_Pointer
	# Current tracer registers:
		# A = ; 0
		# B = ???; 0
		# C = ???; 0
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = String; 1
		# L = String; 1
	BC = 32;
	push DE;		# Makes room by pushing Write_Pointer to stack.
	D = H;		# Moves String into upper register
	E = L;		# Moves into lower register
	H = D;		# Creates copy of String
	L = E;		# Creates copy of String
	HL += BC;		# S_PLUS16
	SP += $02;		# Fixes 'panic' push
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = String; 1
		# E = String; 1
		# H = Write_Pointer; 1
		# L = Write_Pointer; 1
	BC = $02;
	push DE;		# Makes room by pushing String to stack.
	D = H;		# Moves @statement_value@ into upper register
	E = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	[HL] = E; 		# Stores value into memory location
	pop BC;		# Gets String back off the stack.
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = $03;
	push BC;		# Makes room by pushing String to stack.
	B = H;		# Moves  into upper register
	C = L;		# Moves into lower register
	HL = SP + 8;		# Fetches Console_Handle off the stack
	A = [HL];		# Store lower byte temporarily
	HL++;
	H = [HL];		# Store upper byte
	L = A;		# Move lower byte from temp register
	HL += BC;		# S_PLUS16
	[HL] = D; 		# Stores value into memory location
	pop BC;		# Gets String back off the stack.
	# Current tracer registers:
		# A = ???; 0
		# B = String; 1
		# C = String; 1
		# D = Write_Pointer; 1
		# E = Write_Pointer; 1
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	SP += 2;		# Remove local variables from stack
	return;
}

subroutine main
{
	# Current tracer registers:
		# A = ???; 0
		# B = String; 0
		# C = String; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	call Wait_For_VBlank;		# Calls function
	# Current tracer registers:
		# A = ???; 0
		# B = String; 0
		# C = String; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = Console_Handle; 0
		# L = Console_Handle; 0
	HL = $FF40;
	[HL] = 0; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = String; 0
		# C = String; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	BC = $8000;
	push BC;		# Pushes Write_Head to the stack
	BC = main;
	push BC;		# Pushes Read_Head to the stack
	BC = $800;
	push BC;		# Pushes Counter to the stack
	call Conditional_Checker;		# Calls function
	SP += 6;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	BC = $8800;
	push BC;		# Pushes Write_Head to the stack
	BC = __main__Test;
	push BC;		# Pushes Read_Head to the stack
	BC = 17;
	push BC;		# Pushes Counter to the stack
	call Conditional_Checker;		# Calls function
	SP += 6;		# Removes pushed parameters from stack
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	HL = $FF40;
	[HL] = $83; 		# Stores value into memory location
	# Current tracer registers:
		# A = ???; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0

	A = 1;
	A |= A;		# This just gets the CPU flags
	jump zero __if_statement__4;		# If statement jump
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0

	label __do_while_statement__5;		# do/while loop label
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	call Wait_For_VBlank;		# Calls function
	A = 1;
	A |= A;		# This just gets the CPU flags
	jump  zero __do_while_statement__5_memory_cleanup;		# do/while memory-cleanup loop jump
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:
	jump __do_while_statement__5;		# do/while loop jump
	label __do_while_statement__5_memory_cleanup;
	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:


	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	# Register snapshot:
	label __if_statement__4;		# If statement label

	# Current tracer registers:
		# A = ; 0
		# B = ; 0
		# C = ; 0
		# D = Write_Pointer; 0
		# E = Write_Pointer; 0
		# H = ; 0
		# L = ; 0
	return;
}

data __main__Test
{
	"HELLO! I AM TEXT" 0
}

