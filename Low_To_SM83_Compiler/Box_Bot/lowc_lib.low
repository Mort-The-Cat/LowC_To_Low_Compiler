
# Here is the direct Low implementation of the lowc_lib.h functions etc

macro DMA_HRAM_Function $FF80;

# -$D000 equals $3000 in 2's compliment

subroutine load_16
{
    # SP + $03 high
    # SP + $02 low
    HL = SP + $02;
    A = [HL++];
    H = [HL];
    L = A;

    A = [HL++];
    H = [HL];
    L = A;

    return;
}

subroutine write_16
{
    # SP + $04 low address

    # SP + $02 low value

    HL = SP + $02;
    A = [HL++];
    C = A;
    A = [HL++];
    B = A;

    # BC = value

    A = [HL++];
    H = [HL];
    L = A;

    [HL] = C;
    HL++;
    [HL] = B;

    return;
}

subroutine sub16
{
    # SP + $05 high (left)
    # SP + $04 low (left)
    # SP + $03 high (right)
    # SP + $02 low (right)

    HL = SP + $02;
    A = [HL++];
    A ~= A;         # Flips bits
    C = A;
    A = [HL++];
    A ~= A;
    B = A;
    BC++;

    A = [HL++];
    H = [HL];
    L = A;
    HL += BC;

    return;
}

subroutine malloc
{
    HL = SP + $02;
    A = [HL++];
    H = [HL];
    L = A;

    BC = $0007;
    HL += BC;
    H >>>= 1;
    L |>><= 1;
    H >>>= 1;
    L |>><= 1;
    H >>>= 1;
    L |>><= 1;

    D = L;

    HL = $D000;

    # DE becomes 'size' in bytes

    # DE = $D000;
    # BC = $3000;
    A ^= A;
    label Not_Free_Loop;
        A += L;
        L = A;

        C = D;
        A = [HL];
        
        A |= A;
    jump not_zero Not_Free_Loop;
    # We've found something!!!
    label Free_Space;
        HL++;
        A = [HL];
        A |= A;
    jump not_zero Not_Free_Loop;
        C--;
    jump not_zero Free_Space;

    # As soon as it hits zero, we know we've found enough contiguous memory
    # To return the malloc call

    A = L;
    A -= D;
    L = A;

    [HL] = D;   # Writes the size in 8-byte chunks to the malloc map address

    H = $00;
    HL += HL; # x2
    HL += HL; # x4
    HL += HL; # x8
    BC = $D080;
    HL += BC;

    return;

    #
}

subroutine free
{
    # Takes the address
    # Turns it into the 8-byte chunk index
    # Goes to that malloc-map address
    # Zero it out

    # Return

    HL = SP + $02;
    A = [HL++];
    H = [HL];
    L = A;

    # HL is address to free

    BC = $2F80;
    HL += BC;

    # Subtract $D080 from address

    H >>>= 1;
    L |>><= 1;
    H >>>= 1;
    L |>><= 1;
    H >>>= 1;
    L |>><= 1;

    # shift right 3 times

    BC = $D000;
    HL += BC;

    # Add $D000

    [HL] = $00;
    # Write $00 to the address

    return;
}

subroutine init_screen_interrupts
{
    A = $C3;
    [$FF00 + $FF85] = A;
    [$FF00 + $FF88] = A;

    returni;
}

subroutine __dma_HRAM_code__
{
    [$FF00 + C] = A;		# 2 cycle - $01
			# Begins DMA transfer
	label DMA_Loop;
	    B--;				# 1 cycle - $02
	jump not_zero DMA_Loop;	# 3 cycles - $04
	
    return;					# 4 cycles - $05
}

subroutine dma_transfer
{
    A = $C0;    # This is the location of the OAM buffer
    BC = $2946;

    jump DMA_HRAM_Function; # Defined in lowc_lib.h
}

subroutine init_dma
{
    # This is the function that initialises the DMA functionality

    BC = DMA_HRAM_Function; # Dest
    push BC;
    BC = __dma_HRAM_code__; # Source
    push BC;
    BC = $05;               # Length
    push BC;
    call memcpy;
    SP += 6;    # Removes parameters off the stack

    return;
}

subroutine memcpy
{
    # SP + $07 high byte 'Dest'
    # SP + $06 low byte 'Dest'
    # SP + $05 high byte 'Source'
    # SP + $04 low byte 'Source'
    # SP + $03 high byte 'Count'
    # SP + $02 low byte 'Count'
    # SP + $01 function return pointers
    # SP + $00

    # Loads values from registers

    SP += 2;    # SP += 2
    pop DE;     # SP += 2
    pop HL;     # SP += 2
    pop BC;     # SP += 2
    SP += 248;  # SP -= 8

    # gets stack pointer back into original position

    label Copy_Loop;
    A = [HL++];         # Gets source and increments it
    [BC] = A;           # Writes to dest
    BC++;               # Increments dest
    DE--;               # Decrements count
    A = D;
    A |= E;
    jump not_zero Copy_Loop;    # As long as counter != 0, repeat

    return;
}

subroutine memset
{
    # SP + $05 and $06 are 'Dest'
    # SP + $04 is 'Value'
    # SP + $02 and $03 are 'Count'
    # SP + $00 and $01 are function ret pointers

    SP += 2;            # (SP + 2)
    pop DE;             # (SP + 4)      Count
    HL = SP + $00;
    A = [HL++];         #               Value
    SP = HL;            # (SP + 5)
    pop HL;             # (SP + 7)      Dest

    SP += 249;          # (SP + 0)

    label Set_Loop;
    [HL++] = A;         # Writes value
    B = A;              # Temporarily stores value
    DE--;               # Decrements Count
    A = D;
    A |= E;             # Checks count != 0
    A = B;              # Gets value back into A register
    jump not_zero Set_Loop;

    return;
}

subroutine place_spritechain_in_oam_buffer
{
    # SP + 6        - Spritechain data (high)
    # SP + 5        - Spritechain data (low)
    # SP + 4        - Count
    # SP + 3        - Y
    # SP + 2        - X
    # SP + 0 & 1    - Function pointer high+low

    BC = $C0A0;
    A = [BC];
    HL = SP + $04;  # Gets count
    H = [HL];
    H <<>= 1;
    H <<>= 1;
    L = A;
    A += H;
    [BC] = A;

    C = L;      # Sets BC to the OAM buffer pointer

    HL = SP + $05;
    E = [HL];
    HL++;
    D = [HL];   # Sets DE to the spritechain pointer

    label Sprite_Assign_Loop;
        HL = SP + $03;
        A = [DE];   # Gets delta Y off spritechain data
        A += [HL];  # adds Y position to spritechain delta y
        [BC] = A;
        C++;        # Next OAM buffer value
        HL--;       # Goes to the delta X value on the stack
        DE++;       # Goes to next value in spritechain data

        A = [DE];   # Delta X
        A += [HL];  # Adds X position to spritechain delta x
        [BC] = A;
        C++;
        DE++;       # Goes to next value in spritechain data

        A = [DE];   # Tile data
        [BC] = A;
        C++;
        DE++;
        
        A = [DE];   # Attribute/flags data
        [BC] = A;
        C++;
        DE++;

        HL = SP + $04;
        [HL]--;     # Decrement counter
    jump not_zero Sprite_Assign_Loop;

    # We've done everything!
    # Callers of this function will handle the deallocating of the parameters
    # So we don't worry about that here, just return

    return;
}