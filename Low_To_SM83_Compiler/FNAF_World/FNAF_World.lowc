#include "../../stdlow.h"

#include "../../low_macros.h"

#include "lowc_lib.h"

#include "Alphabet_Tiles.h"
#include "Test_Bricks.h"
#include "Background_Tiles.h"
#include "Title_Screen_Tilemap.h"
#include "Plush_Graphics.h"

#include "Screen_Interrupt_Scheduler.h"

const byte Plush_Spritechain[] =
{
	0x00, 0x00, 0x00, 1,
	0x00, 0x08, 0x01, 1,
	0x00, 0x10, 0x02, 1,
	0x00, 0x18, 0x03, 1,
	
	0x08, 0x00, 0x04, 1,
	0x08, 0x08, 0x05, 1,
	0x08, 0x10, 0x06, 1,
	0x08, 0x18, 0x07, 1,
	
	0x10, 0x00, 0x08, 1,
	0x10, 0x08, 0x09, 1,
	0x10, 0x10, 0x0A, 1,
	0x10, 0x18, 0x0B, 1,
	
	0x18, 0x00, 0x0C, 1,
	0x18, 0x08, 0x0D, 1,
	0x18, 0x10, 0x0E, 1,
	0x18, 0x18, 0x0F, 1,
	
	0x20, 0x00, 0x10, 1,
	0x20, 0x08, 0x11, 1,
	0x20, 0x10, 0x12, 1,
	0x20, 0x18, 0x13, 1
};

#define OAM_BUFFER addressof(0xC000)

void Wait_For_VBlank()
{
	byte Scanline;

	do
	{
		Scanline = *LCDY_REGISTER;
	} while (Scanline < VBLANK_SCANLINE);

	return;
}

const byte OAM_Tester[] =
{
	//	0xYY	0xXX	0xTT	0xFF
		0x30,	0x40,	0x00,	0x00,
		0x30,	0x48,	0x04,	0x00,

		0x38,	0x40,	0x02,	0x00,
		0x38,	0x48,	0x05,	0x00
};

const byte Test_Palettes[] =
{
	0xFF, 0xFF,				// black
	31, 0,				// red
	0xE0, 0x03,			// green

	0, 252				// blue
};

const byte Blue_Palette[] =
{
	0xFF,	0x7F,			// white
	0xE7,	252,			// light blue (2 red, 2 green, 31 blue)
	0,		240,			// blue
	0,		0				// black
};

const byte FNAF_World_Palette[] =
{
	0xFF,	0x7F,	// white
	21,		127,	// light blue
	0,		97,		// blue
	0,		0,		// black
	// Bonnie / SKY

	0xFF,	0x7F,	// white
	29,		66,
	243,	0,		// brown
	0,		0,		// black
	// Freddy / foxy

	0xFF,	0x7F,	// white
	27,		79,		// pale
	121,	22,		// yellow
	179,	00,		// orange
	// Chica / Fredbear

	236,	17,		// dark grass green
	213,	26,		// pale leaf green
	144,	17,		// autumn wood
	202,	0,		// dark wood
	// Forest terrain

	43,		126,
	217,	90,		// tan
	121,	22,
	175,	125
	// Sky/background
};

void Write_Tilemap_Attributes()
{
	memset(VRAM_TILEM_0, 4, 0x180);
	memset( (VRAM_TILEM_0 + 0x180), 3, 0xC0);

	return;
}

void Generate_Palettes(byte* Destination)
{
	byte* Data;
	byte Count;

	*Destination = 0x80;	// start from the beginning and auto-increment to the end

	Destination++;

	Data = FNAF_World_Palette;
	Count = sizeof(FNAF_World_Palette);

	do
	{
		*Destination = *Data;
		Data++;
		Count--;
	} while (Count);

	return;
}

void Set_Interrupt_Function(byte* Address, byte* Function_Pointer)
{
	*Address = (byte)Function_Pointer;
	Address++;
	*Address = high(Function_Pointer);

	return;
}

#define Frame_Counter addressof(0xC100)	// This is a 2-byte value
#define Parallax_LYC_Data addressof(0xC103) // The LYC at which the next parallax interrupt should be triggered
	// LYC pos
#define Parallax_Scroll_Data addressof(0xC106) // The scroll value that should be applied to the scanlines
#define Parallax_Index addressof(0xC102) // This is the index into the parallax_data table

void Test_Titlescreen_Vblank()
{
	push();

	*BACKGROUND_SCROLL_Y_REGISTER = 40;

	*BACKGROUND_SCROLL_X_REGISTER = *Parallax_Scroll_Data;

	pop();

	enablei();

	return;
}

void Init_Parallax_Data()
{
	const byte Parallax_Data[] =
	{
		47, 63, 79, 255
	};

	memcpy(Parallax_LYC_Data, Parallax_Data, sizeof(Parallax_Data));

	return;
}

void Write_Parallax_Data()
{
	*Parallax_Index = 0;

	byte* Address;
	word Frame_Count;
	Address = Frame_Counter;
	Frame_Count = *Address;
	Address++;
	store_high(Frame_Count, *Address);

	Frame_Count = shift_left(Frame_Count);

	Address = Parallax_Scroll_Data;
	*Address = (byte)Frame_Count;	// Top set of clouds
	Address++;
	Frame_Count = shift_right(Frame_Count);
	*Address = (byte)Frame_Count;	// medium clouds
	Address++;
	Frame_Count = shift_right(Frame_Count);
	*Address = (byte)Frame_Count;	// bottom clouds
	Address++;
	*Address = 0;					// land, (no scroll)

	return;
}

void Increment_Frame_Counter()
{
	*(Frame_Counter)++;

	return;
}

void main()
{
	Wait_For_VBlank();

	*LCDC_REGISTER = 0;

	// memcpy(VRAM_BLOCK_0, Brick_Graphics, sizeof(Brick_Graphics));

	memcpy(VRAM_BLOCK_0, Plush_Graphics, sizeof(Plush_Graphics));

	memcpy(VRAM_BLOCK_1, Alphabet_Graphics, sizeof(Alphabet_Graphics));

	memcpy( (VRAM_BLOCK_1 + sizeof(Alphabet_Graphics)), Title_Screen_UI_Blocks, sizeof(Title_Screen_UI_Blocks));

	memcpy( VRAM_BLOCK_2, Sky_Graphics, sizeof(Sky_Graphics));

	const byte String[] = "TESTING MEMCPY";

	memcpy(VRAM_TILEM_0, Title_Screen_Tilemap, sizeof(Title_Screen_Tilemap));

	memcpy(VRAM_TILEM_0, String, (sizeof(String) + 0xFFFF) );

	memcpy(OAM_BUFFER, OAM_Tester, sizeof(OAM_Tester));

	init_dma();	// This initialises the DMA code
	init_screen_interrupts();

	Init_Parallax_Data();

	Generate_Palettes(CGB_BG_PALETTE_SPECIFIER);

	Generate_Palettes(CGB_OBJ_PALETTE_SPECIFIER);

	*VRAM_BANK = 1;			// Swaps to attribute bank

	memcpy(VRAM_TILEM_0, Title_Screen_Attribute_Map, sizeof(Title_Screen_Attribute_Map));

	// Write_Tilemap_Attributes();

	*VRAM_BANK = 0;			// Swaps back to regular bank

	Set_Interrupt_Function(VBLANK_HRAM_FUNCTION_JUMP_ADDRESS, Test_Titlescreen_Vblank);

	*INTERRUPT_ENABLE_REGISTER = 1;

	// *OBJECT_PALETTE_0_REGISTER = 0xE4;

	*LCDC_REGISTER = 0x83;

	do
	{
		*OAM_BUFFER_COUNTER = 0;
		Increment_Frame_Counter();
		Write_Parallax_Data();
		place_spritechain_in_oam_buffer(Plush_Spritechain, 20, 70, 75);
		Wait_For_VBlank();
		dma_transfer();		// This places the OAM buffer into OAM
	} while (1);

	return;
}