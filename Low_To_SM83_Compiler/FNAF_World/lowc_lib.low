
# Here is the direct Low implementation of the lowc_lib.h functions etc

macro DMA_HRAM_Function $FF80;

subroutine init_screen_interrupts
{
    A = $C3;
    [$FF00 + $FF85] = A;
    [$FF00 + $FF88] = A;

    return;
}

subroutine __dma_HRAM_code__
{
    [$FF00 + C] = A;		# 2 cycle - $01
			# Begins DMA transfer
	label DMA_Loop;
	    B--;				# 1 cycle - $02
	jump not_zero DMA_Loop;	# 3 cycles - $04
	
    return;					# 4 cycles - $05
}

subroutine dma_transfer
{
    A = $C0;    # This is the location of the OAM buffer
    BC = $2946;

    jump DMA_HRAM_Function; # Defined in lowc_lib.h
}

subroutine init_dma
{
    # This is the function that initialises the DMA functionality

    BC = DMA_HRAM_Function; # Dest
    push BC;
    BC = __dma_HRAM_code__; # Source
    push BC;
    BC = $05;               # Length
    push BC;
    call memcpy;
    SP += 6;    # Removes parameters off the stack

    return;
}

subroutine memcpy
{
    # SP + $07 high byte 'Dest'
    # SP + $06 low byte 'Dest'
    # SP + $05 high byte 'Source'
    # SP + $04 low byte 'Source'
    # SP + $03 high byte 'Count'
    # SP + $02 low byte 'Count'
    # SP + $01 function return pointers
    # SP + $00

    # Loads values from registers

    SP += 2;    # SP += 2
    pop DE;     # SP += 2
    pop HL;     # SP += 2
    pop BC;     # SP += 2
    SP += 248;  # SP -= 8

    # gets stack pointer back into original position

    label Copy_Loop;
    A = [HL++];         # Gets source and increments it
    [BC] = A;           # Writes to dest
    BC++;               # Increments dest
    DE--;               # Decrements count
    A = D;
    A |= E;
    jump not_zero Copy_Loop;    # As long as counter != 0, repeat

    return;
}

subroutine memset
{
    # SP + $05 and $06 are 'Dest'
    # SP + $04 is 'Value'
    # SP + $02 and $03 are 'Count'
    # SP + $00 and $01 are function ret pointers

    SP += 2;            # (SP + 2)
    pop DE;             # (SP + 4)      Count
    HL = SP + $00;
    A = [HL++];         #               Value
    SP = HL;            # (SP + 5)
    pop HL;             # (SP + 7)      Dest

    SP += 249;          # (SP + 0)

    label Set_Loop;
    [HL++] = A;         # Writes value
    B = A;              # Temporarily stores value
    DE--;               # Decrements Count
    A = D;
    A |= E;             # Checks count != 0
    A = B;              # Gets value back into A register
    jump not_zero Set_Loop;

    return;
}

subroutine place_spritechain_in_oam_buffer
{
    # SP + 6        - Spritechain data (high)
    # SP + 5        - Spritechain data (low)
    # SP + 4        - Count
    # SP + 3        - Y
    # SP + 2        - X
    # SP + 0 & 1    - Function pointer high+low

    BC = $C0A0;
    A = [BC];
    HL = SP + $04;  # Gets count
    H = [HL];
    H <<>= 1;
    H <<>= 1;
    L = A;
    A += H;
    [BC] = A;

    C = L;      # Sets BC to the OAM buffer pointer

    HL = SP + $05;
    E = [HL];
    HL++;
    D = [HL];   # Sets DE to the spritechain pointer

    label Sprite_Assign_Loop;
        HL = SP + $03;
        A = [DE];   # Gets delta Y off spritechain data
        A += [HL];  # adds Y position to spritechain delta y
        [BC] = A;
        C++;        # Next OAM buffer value
        HL--;       # Goes to the delta X value on the stack
        DE++;       # Goes to next value in spritechain data

        A = [DE];   # Delta X
        A += [HL];  # Adds X position to spritechain delta x
        [BC] = A;
        C++;
        DE++;       # Goes to next value in spritechain data

        A = [DE];   # Tile data
        [BC] = A;
        C++;
        DE++;
        
        A = [DE];   # Attribute/flags data
        [BC] = A;
        C++;
        DE++;

        HL = SP + $04;
        [HL]--;     # Decrement counter
    jump not_zero Sprite_Assign_Loop;

    # We've done everything!
    # Callers of this function will handle the deallocating of the parameters
    # So we don't worry about that here, just return

    return;
}